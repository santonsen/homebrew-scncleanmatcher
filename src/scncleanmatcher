#!/usr/bin/env python

import sys, os, re
import difflib
import argparse

class CleanMatcher():

    def __init__(self):
        self.hidden = False

        # get the user input
        args = self._parser()

        # get folder(s)
        folders = args.folders
        self.path = folders
        # get the match_string
        self.match_string = args.matchstring

        # set debug or not
        self.debug = args.debug

        # do the matching
        self.getMatches()

    def setMatchString(self, match_string):
        self.match_string = match_string

    def getMatchString(self):
        return self.match_string

    def setPath(self, path):
        self.path = path

    def getPath(self):
        return self.path

    def setHidden(self,hidden):
        if type(hidden) == bool:
            self.hidden = hidden
        else:
            raise Exception("setHidden requires a bool value")
    def getHidden(self):
        return self.hidden

    def getMatches(self):
        # this can take either a list of paths or a single path
        if type(self.path) == list:
            for path in self.path:
                matches = self._getClnMatches(\
                                              self._getAllFiles(path,
                                                                self.hidden),
                                              self._getClnFiles(path,
                                                                self.match_string,
                                                                self.hidden),
                                              self.debug)
        elif type(self.path) == str:
            matches = self._getClnMatches(\
                                          self._getAllFiles(self.path,
                                                            self.hidden),
                                          self._getClnFiles(self.path,
                                                            self.match_string,
                                                            self.hidden),
                                          self.debug)
        return matches


    def _parser(self):
        parser = argparse.ArgumentParser(prog='scncleanmatcher',
                                         description='A script that scrapes through folder(s)' + \
                                         'and fuzzy matches files based on a string.',
                                         usage='scncleanmatcher folder(s) [-h]\n' + \
                                         'example: scncleanmatcher /Volumes/scn_commercial/statoil_ally_120914_rg/')
        parser.add_argument('folders', help='Target folder name(s)',
                            metavar='FOLDER')
        parser.add_argument('-m', '--matchstring',
                            help='Specify a match string.\nDefault is "_CLN_"'+\
                            'The match string is case insensitive.',
                            default='_CLN_')
        parser.add_argument('-d', '--debug', help='Turn on debugging',
                            action='store_true')
        if len(sys.argv) > 0:
            args = parser.parse_args()
        else:
            print 'scncleanmatcher: error: too few arguments\n'
            parser.print_help()
            sys.exit(0)

        return args

    def _getAllFiles(self, path, hidden=False):
        files = []
        for (dirpath, dirnames, filenames) in os.walk(path):
            if hidden:
                files.extend(filenames)
            else:
                filenames = [f for f in filenames if not f[0] == '.']
                dirnames[:] = [d for d in dirnames if not d[0] == '.']
                files.extend(filenames)
            if files == []:
                return 'No files in %s' % path
            else:
                return files


    def _getClnFiles(self, path, match_string, hidden=False):
        f = []
        cln_files = []
        for (dirpath, dirnames, filenames) in os.walk(path):
            if hidden:
                f.extend(filenames)
            else:
                filenames = [x for x in filenames if not x[0] == '.']
                dirnames[:] = [d for d in dirnames if not d[0] == '.']
                f.extend(filenames)

        for filename in f:
            # case insensitive search for match_string
            search_result = re.search(match_string, filename, re.I)
            # if _cln_ is found, add it to cln_files
            if search_result != None:
                cln_files.append(filename)

        return cln_files


    def _getClnMatches(self, files, cln_files, debug=False):
        matches = []
        # split the clean and normal files
        dirty_files = []

        for f in files:
            if f not in cln_files:
                dirty_files.append(f)
        if debug:
            print "\ndirty files: %s\n" % dirty_files
            print 'clean files: %s\n' % cln_files

        for f in dirty_files:
            best_ratio = 0
            best_match = None
            for c in cln_files:
                match_ratio = difflib.SequenceMatcher(None, f, c).ratio()
                if match_ratio > best_ratio and match_ratio > 0.9:
                    best_ratio = match_ratio
                    best_match = c
            if best_match != None:
                cln_files.remove(best_match)
            print "MATCH: %s -->> %s" % (f, best_match)
            matches.append([f, best_match])

        return matches


if __name__ == '__main__':
    scncleanmatcher = CleanMatcher()
